import{a7 as U,a8 as k,j as p,q as M,a9 as x,D as T,M as F,L,d as S,H as q,aa as z,ab as b,a6 as O,ac as K,ad as R,ae as B,I as H,af as V,ag as N}from"./app-CpRdxx_q.js";import{v as Y,i as G,e as _}from"./useForwardExpose-CoOY80bG.js";function J(t,e){const n=typeof t=="string"&&!e?`${t}Context`:e,a=Symbol(n);return[i=>{const r=U(a,i);if(r||r===null)return r;throw new Error(`Injection \`${a.toString()}\` not found. Component must be used within ${Array.isArray(t)?`one of the following components: ${t.join(", ")}`:`\`${t}\``}`)},i=>(k(a,i),i)]}const[D,oe]=J("ConfigProvider");function ie(t){const e=D({dir:p("ltr")});return M(()=>{var n;return(t==null?void 0:t.value)||((n=e.dir)==null?void 0:n.value)||"ltr"})}let Q=0;function se(t,e="reka"){const n=D({useId:void 0});return x?`${e}-${x()}`:n.useId?`${e}-${n.useId()}`:`${e}-${++Q}`}function X(t,e){const n=p(t);function a(u){return e[n.value][u]??n.value}return{state:n,dispatch:u=>{n.value=a(u)}}}function Z(t,e){var h;const n=p({}),a=p("none"),o=p(t),u=t.value?"mounted":"unmounted";let i;const r=((h=e.value)==null?void 0:h.ownerDocument.defaultView)??Y,{state:v,dispatch:f}=X(u,{mounted:{UNMOUNT:"unmounted",ANIMATION_OUT:"unmountSuspended"},unmountSuspended:{MOUNT:"mounted",ANIMATION_END:"unmounted"},unmounted:{MOUNT:"mounted"}}),c=l=>{var m;if(G){const g=new CustomEvent(l,{bubbles:!1,cancelable:!1});(m=e.value)==null||m.dispatchEvent(g)}};T(t,async(l,m)=>{var P;const g=m!==l;if(await F(),g){const $=a.value,E=C(e.value);l?(f("MOUNT"),c("enter"),E==="none"&&c("after-enter")):E==="none"||E==="undefined"||((P=n.value)==null?void 0:P.display)==="none"?(f("UNMOUNT"),c("leave"),c("after-leave")):m&&$!==E?(f("ANIMATION_OUT"),c("leave")):(f("UNMOUNT"),c("after-leave"))}},{immediate:!0});const s=l=>{const m=C(e.value),g=m.includes(l.animationName),P=v.value==="mounted"?"enter":"leave";if(l.target===e.value&&g&&(c(`after-${P}`),f("ANIMATION_END"),!o.value)){const $=e.value.style.animationFillMode;e.value.style.animationFillMode="forwards",i=r==null?void 0:r.setTimeout(()=>{var E;((E=e.value)==null?void 0:E.style.animationFillMode)==="forwards"&&(e.value.style.animationFillMode=$)})}l.target===e.value&&m==="none"&&f("ANIMATION_END")},d=l=>{l.target===e.value&&(a.value=C(e.value))},A=T(e,(l,m)=>{l?(n.value=getComputedStyle(l),l.addEventListener("animationstart",d),l.addEventListener("animationcancel",s),l.addEventListener("animationend",s)):(f("ANIMATION_END"),i!==void 0&&(r==null||r.clearTimeout(i)),m==null||m.removeEventListener("animationstart",d),m==null||m.removeEventListener("animationcancel",s),m==null||m.removeEventListener("animationend",s))},{immediate:!0}),y=T(v,()=>{const l=C(e.value);a.value=v.value==="mounted"?l:"none"});return L(()=>{A(),y()}),{isPresent:M(()=>["mounted","unmountSuspended"].includes(v.value))}}function C(t){return t&&getComputedStyle(t).animationName||"none"}const re=S({name:"Presence",props:{present:{type:Boolean,required:!0},forceMount:{type:Boolean}},slots:{},setup(t,{slots:e,expose:n}){var f;const{present:a,forceMount:o}=q(t),u=p(),{isPresent:i}=Z(a,u);n({present:i});let r=e.default({present:i.value});r=z(r||[]);const v=b();if(r&&(r==null?void 0:r.length)>1){const c=(f=v==null?void 0:v.parent)!=null&&f.type.name?`<${v.parent.type.name} />`:"component";throw new Error([`Detected an invalid children for \`${c}\` for  \`Presence\` component.`,"","Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.","You can apply a few solutions:",["Provide a single child element so that `presence` directive attach correctly.","Ensure the first child is an actual element instead of a raw text node or comment node."].map(s=>`  - ${s}`).join(`
`)].join(`
`))}return()=>o.value||a.value||i.value?O(e.default({present:i.value})[0],{ref:c=>{const s=_(c);return typeof(s==null?void 0:s.hasAttribute)>"u"||(s!=null&&s.hasAttribute("data-reka-popper-content-wrapper")?u.value=s.firstElementChild:u.value=s),s}}):null}});function W(t){const e=b(),n=e==null?void 0:e.type.emits,a={};return n!=null&&n.length||console.warn(`No emitted event found. Please check component: ${e==null?void 0:e.type.__name}`),n==null||n.forEach(o=>{a[K(R(o))]=(...u)=>t(o,...u)}),a}function ee(t){const e=b(),n=Object.keys((e==null?void 0:e.type.props)??{}).reduce((o,u)=>{const i=(e==null?void 0:e.type.props[u]).default;return i!==void 0&&(o[u]=i),o},{}),a=B(t);return M(()=>{const o={},u=(e==null?void 0:e.vnode.props)??{};return Object.keys(u).forEach(i=>{o[R(i)]=u[i]}),Object.keys({...n,...o}).reduce((i,r)=>(a.value[r]!==void 0&&(i[r]=a.value[r]),i),{})})}function ue(t,e){const n=ee(t),a=e?W(e):{};return M(()=>({...n.value,...a}))}function w(){const t=p(),e=M(()=>{var n,a;return["#text","#comment"].includes((n=t.value)==null?void 0:n.$el.nodeName)?(a=t.value)==null?void 0:a.$el.nextElementSibling:_(t)});return{primitiveElement:t,currentElement:e}}const j="data-reka-collection-item";function ce(t={}){const{key:e="",isProvider:n=!1}=t,a=`${e}CollectionProvider`;let o;if(n){const c=p(new Map);o={collectionRef:p(),itemMap:c},k(a,o)}else o=U(a);const u=(c=!1)=>{const s=o.collectionRef.value;if(!s)return[];const d=Array.from(s.querySelectorAll(`[${j}]`)),y=Array.from(o.itemMap.value.values()).sort((I,h)=>d.indexOf(I.ref)-d.indexOf(h.ref));return c?y:y.filter(I=>I.ref.dataset.disabled!=="")},i=S({name:"CollectionSlot",setup(c,{slots:s}){const{primitiveElement:d,currentElement:A}=w();return T(A,()=>{o.collectionRef.value=A.value}),()=>O(N,{ref:d},s)}}),r=S({name:"CollectionItem",inheritAttrs:!1,props:{value:{validator:()=>!0}},setup(c,{slots:s,attrs:d}){const{primitiveElement:A,currentElement:y}=w();return H(I=>{if(y.value){const h=V(y.value);o.itemMap.value.set(h,{ref:y.value,value:c.value}),I(()=>o.itemMap.value.delete(h))}}),()=>O(N,{...d,[j]:"",ref:A},s)}}),v=M(()=>Array.from(o.itemMap.value.values())),f=M(()=>o.itemMap.value.size);return{getItems:u,reactiveItems:v,itemMapSize:f,CollectionSlot:i,CollectionItem:r}}export{re as P,ie as a,se as b,J as c,ee as d,ue as e,w as f,W as g,D as i,ce as u};
